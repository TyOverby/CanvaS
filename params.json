{"name":"CanvaS","tagline":"Easy image processing/creation in Scala","body":"### Welcome to CanvaS, first a small intro, then some code. \r\nEarlier this year I really got into image manipulation and algorithmic image generation.  Doing it in other languages seemed clumsy and the domain specific tools available didn't offer the powerful scripting environments that I rely on.  After looking at Scala, I realized that I could create a domain specific language that would be extensible, powerful and fast.\r\n\r\nLater I'll show how to set up an environment for the scripts, but lets look at some code first.\r\n\r\n### Sample Code\r\n\r\n## Basic Drawing\r\nCanvaS provides many functions from Java's Grahpics2D class.\r\nThis enables basic drawing functionality, though isn't the core of CanvaS. \r\n\r\n{% highlight scala %}\r\nwidth = 256\r\nheight = 256\r\n\r\ncolor = Color(255, 0, 0)\r\nfillRect(0, 0, width / 2, height / 2)\r\ndrawLine(0, 0, width, height)\r\nfillOval(width / 2, 0, width / 2, height / 2)\r\ndrawRoundRect(25, height / 2 + 25, width/2 - 50, height/2 - 50, 20, 20)\r\n{% endhighlight %}\r\n\r\n## Higher Order Functions on Pixels and Positions\r\nMany operations on pixels can be expressed as a single function.  CanvaS offers a 'map' function that can be used to great effect.  \r\n\r\nIn this example, we map the x and y coordinates to green and blue pixels on the canvas.  \r\n{% highlight scala %}\r\nwidth = 256\r\nheight = 256\r\n\r\n// (Int, Int) => Color\r\nmapPosition {\r\n    case (x, y) => Color(0, x, y)\r\n}\r\n{% endhighlight %}\r\n\r\nWe can also load images from our computer or the web and apply transformations from the previous color to another color.\r\n{% highlight scala %}\r\nload(\"example_input/fat_cat.jpg\")\r\n\r\nmapColor {\r\n    case Color(r, g, b) => {\r\n        val c = (r + g + b) / 3  // Compute the average value \r\n        Color(c, c, c)           // use this average for each (r,g,b) component\r\n    }\r\n}\r\n{% endhighlight %}\r\n\r\n{% highlight scala %}\r\nload(\"http://i.imgur.com/GWLF4UQ.jpg\")\r\n\r\nmapColor {\r\n    case Color(r, g, b) => Color(b, g, r)  // Reverse (r,g,b) to (b,g,r)\r\n}\r\n{% endhighlight %}\r\nIf you want to outsmart the check that I perform on 'load' you can also use 'loadFile' and 'loadUrl' for self-documentation.  \r\n\r\n\r\nOne last example, my favorite generated image is very easy to express as a function.  If you want to find out why this works, get ready to break out your truth tables!\r\n{% highlight scala %}\r\nwidth = 256\r\nheight = 256\r\n\r\nmapPosition {\r\n    case (x, y) => Color(x ^ y, x ^ y, x ^ y)\r\n}\r\n{% endhighlight %}\r\nNote that this code would break if our image was any bigger because it would try to produce (r, g, b) values greater than 255.\r\n\r\n## Canvas Modification\r\nSometimes it is handy to be able to modify the entire canvas by applying common operations like translating, scaling, and shearing.\r\n\r\nIt is simple to apply any of these transformations.\r\n\r\n{% highlight scala %}\r\nload(\"example_input/cute_cat.jpg\")\r\n\r\n//     angle       centerX, centerY\r\nrotate(45 degrees, width/2, height/2) \r\n{% endhighlight %}\r\n\r\nNotice two things:\r\n\r\n* We implicitly converted from degrees to radians with the 'degrees' postfix-operator.\r\n* The un-rotated picture of the cat is still in the background.  \r\n\r\nBecause we sometimes want this behavior, and it would be silly of me to guess what color you actually wanted the background to be, what we'll see next will solve this issue. \r\n\r\n\r\nIf you wanted to perform many of these modifications to the canvas, there would be a lot of copying going on.  For this, I provide the 'chainedOps' object which allows you to, well, chain operations which look like they will be computed sequentially, but are actually all done at once!  Here's what some look like: \r\n\r\n{% highlight scala %}\r\nload(\"example_input/cute_cat.jpg\")\r\n\r\nchainedOps\r\n    .rotate(30 degrees, width / 2, height / 2)\r\n    .translate(-width / 2, -height / 2)\r\n    .scale(2)\r\n    .translate(width / 2+100, height / 2 + 100)\r\n    .run()\r\n\r\n{% endhighlight %}\r\n\r\nNeat! But how does this help with the background issue?  Another function on chainedOps lets us set the background color used during a transformation.  \r\n\r\n{% highlight scala %}\r\nload(\"example_input/cute_cat.jpg\")\r\n\r\nchainedOps\r\n    .rotate(45 degrees, width / 2, height / 2)\r\n    .withBackground(Color(0, 0, 0))\r\n    .run()\r\n{% endhighlight %}\r\n\r\nThere we go!  And obviously, we can have as many transformations in that chain as we want.\r\n\r\n\r\n## File IO, Displaying, and Saving Images \r\nYou've already seen 'load', but 'loadFile' and 'loadUrl' also exist if you want to be explicit about where you are getting your resource from. \r\n\r\nWe also have the 'writeTo' function, which takes a file path and saves the current image to that path.\r\n\r\n{% highlight scala %}\r\nload(\"example_input/cute_cat.jpg\")\r\n\r\nmapColor {\r\n    case Color(r, g, b) => {\r\n        val c = (r + g + b)/3\r\n        if (c < 50) Color(0, 0, 0)  else Color(255, 255, 255)\r\n    }\r\n}\r\n\r\nwriteTo(\"example_output/black_and_white_cat.png\")\r\n{% endhighlight %}\r\n\r\nFor quick iterations, it would be nice if our program could pop up a window with our image in it instead of having to save the picture and then open it up to view it.  Luckily I thought of that, and provide the methods `show()` and `show(title)`.  These will pop up a window that displays the image at the current point.  This means that you can call show multiple times during a multi-step process and it will show all of the steps. \r\n{% highlight scala %}\r\nload(\"example_input/trees.jpg\")\r\n\r\nshow(\"unscaled\")\r\n\r\nscale(0.5)\r\nwidth /= 2\r\nheight /= 2\r\n\r\nshow(\"scaled\")\r\n{% endhighlight %}\r\n\r\nThat's all the file IO and display things, but here are some more notes:\r\n\r\nSetting 'width' and 'height' after they were first set or after a `load(file)` call will crop the image to the new width and height.  You can also crop an area using the function 'crop(x, y, width, height)'.\r\n\r\n\r\nIf you want to use this code to generate a java.awt.BufferedImage, simply instantiate a class that extends Canvas and then access the 'imageBuffer' field on it. \r\n`val image = ((new MyCanvas).imageBuffer)` \r\n\r\n\r\n## Actually getting this code working\r\n\r\nYou will need 3 things in order to actually start manipulating images programmatically. \r\n\r\n1. The Scala Compiler\r\n2. An IDE that supports Scala\r\n3. My library.\r\n\r\n(SBT support coming soon)\r\n\r\nOnce you have the above required programs and library, it is time to actually run some code.  Fortunately, I've made it incredibly easy to do so!  The Canvas class contains all the functions that you've been reading about, so we simply need to do one extension and we're good.  The complete code for the previous example is just this:\r\n\r\n{% highlight scala %}\r\nimport com.prealpha.Canvas\r\nobject MyCanvas extends Canvas {\r\n    load(\"example_input/trees.jpg\")\r\n\r\n    show(\"unscaled\")\r\n\r\n    scale(0.5)\r\n    width /= 2\r\n    height /= 2\r\n\r\n    show(\"scaled\")\r\n}\r\n{% endhighlight %}\r\n\r\nNotice that the only difference between my example scripts and the code that actually runs is the import and that we wrap everything in an `object` that extends `Canvas`!  Because `Canvas` extends `App`, the entrypoint to our program is also inside MyCanvas as well!  We can have a fully running image generator in fewer lines than it takes to write \"Hello World\" in Java.  ","google":"UA-39053579-1","note":"Don't delete this file! It's used internally to help with page regeneration."}