---
layout: main
title: CanvaS
tagline: I don't even know
---

This is some content wouldn't you say?

{% include code %}
{% highlight scala linenos %}
val x = "hi"
{% endhighlight %}
{% include inbetween %}

{% include image %}
    <img src ="./example_output/basicDrawing.png" />
{% include image %}



Earlier this year I really got into image manipulation and algorithmic image generation.
Doing it in other languages seemed clumsy and the domain specific tools available didn't
offer the powerful scripting environments that I rely on.  After looking at Scala, I
realized that I could create a domain specific language that would be extensible, powerful and fast.

Later I'll show how to set up an environment for the scripts, but lets look at some code first.

<h1> Sample Code </h1>

<h2> Basic Drawing </h2>
CanvaS provides many functions from Java's Grahpics2D class.
This enables basic drawing functionality, though isn't the core of CanvaS. 

{% include code %}
{% highlight scala  linenos %}
width = 256
height = 256

color = Color(255, 0, 0)
fillRect(0, 0, width / 2, height / 2)
drawLine(0, 0, width, height)
fillOval(width / 2, 0, width / 2, height / 2)
drawRoundRect(25, height / 2 + 25,
    width/2 - 50, height/2 - 50, 20, 20)
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/basicDrawing.png" />
{% include image %}

<h2> Higher Order Functions on Pixels and Positions </h2>
<p>
    Many operations on pixels can be expressed as a single function.
    CanvaS offers a 'map' function that can be used to great effect.
</p>
<p>
    In this example, we map the x and y coordinates to green and blue pixels on the canvas.
</p>
{% include code %}
{% highlight scala %}
width = 256
height = 256

// (Int, Int) => Color
mapPosition {
    case (x, y) => Color(0, x, y)
}
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/mapPosition_example.png" />
{% include image %}

<p>
    We can also load images from our computer or the web and apply transformations from the previous color to another color.
</p>
{% include code %}
{% highlight scala %}
load("example_input/fat_cat.jpg")

mapColor {
    case Color(r, g, b) => {
        // Compute the average value
        val c = (r + g + b) / 3
        // use this average for each (r,g,b) component
        Color(c, c, c)
    }
}
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/fat_cat_out.png" />
{% include image %}

{% include code %}
{% highlight scala %}
load("http://i.imgur.com/GWLF4UQ.jpg")

mapColor {
    case Color(r, g, b) => Color(b, g, r)  // Reverse (r,g,b) to (b,g,r)
}
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/funny_fish.png" />
{% include image %}
<p>
    If you want to outsmart the check that I perform on 'load' you can also use 'loadFile' and 'loadUrl' for self-documentation.
</p><p>
    One last example, my favorite generated image is very easy to express as a function.
    If you want to find out why this works, get ready to break out your truth tables!
</p>
{% include code %}
{% highlight scala %}
width = 256
height = 256

mapPosition {
    case (x, y) => Color(x ^ y, x ^ y, x ^ y)
}
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/xxory.png" />
{% include image %}
<p><small>
    Note that this code would break if our image was any bigger because
    it would try to produce (r, g, b) values greater than 255.
</small></p>

<h2> Canvas Modification </h2>
<p>
    Sometimes it is handy to be able to modify the entire canvas by applying common
    operations like translating, scaling, and shearing.
</p>

<p>
    It is simple to apply any of these transformations.
</p>

{% include code %}
{% highlight scala %}
load("example_input/cute_cat.jpg")

//     angle       centerX, centerY
rotate(45 degrees, width/2, height/2) 
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/cute_rotation.png" />
{% include image %}

<h3>Notice two things:</h3>

        <ul>
            <li>
                We implicitly converted from degrees to radians with the 'degrees' postfix-operator.
            </li>
            <li>
                The un-rotated picture of the cat is still in the background.
            </li>
        </ul>


<p>
    If you wanted to perform many of these modifications to the canvas, there would be a lot of copying going on.
    For this, I provide the 'chainedOps' object which allows you to, well, chain operations which look like they will
    be computed sequentially, but are actually all done at once!  Here's what some look like:
</p>

{% include code %}
{% highlight scala %}
load("example_input/cute_cat.jpg")

chainedOps
    .rotate(30 degrees, width / 2, height / 2)
    .translate(-width / 2, -height / 2)
    .scale(2)
    .translate(width / 2+100, height / 2 + 100)
    .run()

{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/complex_cute.png" />
{% include image %}

<p>
    Neat! But how does this help with the background issue?
    Another function on chainedOps lets us set the background color used during a transformation.
</p>

{% include code %}
{% highlight scala %}
load("example_input/cute_cat.jpg")

chainedOps
    .rotate(45 degrees, width / 2, height / 2)
    .withBackground(Color(0, 0, 0))
    .run()
{% endhighlight %}
{% include inbetween %}
TODO: regen this one <!--<img src ="./example_output/.png" /> -->
{% include image %}

<p>
    There we go!  And obviously, we can have as many transformations in that chain as we want.
</p>

<h2> File IO, Displaying, and Saving Images </h2>
<p>
    You've already seen 'load', but 'loadFile' and 'loadUrl' also exist if
    you want to be explicit about where you are getting your resource from.
</p><p>
    We also have the 'writeTo' function, which takes a file path and saves the current image to that path.
</p>

{% include code %}
{% highlight scala %}
load("example_input/cute_cat.jpg")

mapColor {
    case Color(r, g, b) => {
        val c = (r + g + b)/3
        if (c < 50) Color(0, 0, 0)  else Color(255, 255, 255)
    }
}

writeTo("example_output/black_and_white_cat.png")
{% endhighlight %}
{% include inbetween %}
    <img src ="./example_output/black_and_white_cat.png" />
{% include image %}

<p>
    For quick iterations, it would be nice if our program could pop up a window with our image in it instead of
    having to save the picture and then open it up to view it.  Luckily I thought of that, and provide the
    methods `show()` and `show(title)`.  These will pop up a window that displays the image at the current point.
    This means that you can call show multiple times during a multi-step process and it will show all of the steps.
</p>
{% include code %}
{% highlight scala %}
load("example_input/trees.jpg")

show("unscaled")

scale(0.5)
width /= 2
height /= 2

show("scaled")
{% endhighlight %}
{% include inbetween %}
<img width=255 height=255 src ="./example_output/trees2.png" />
{% include image %}

<p>
    That's all the file IO and display things, but here are some more notes:
</p><p>
Setting 'width' and 'height' after they were first set or after a `load(file)` call will crop the image to
the new width and height.  You can also crop an area using the function 'crop(x, y, width, height)'.
</p><p>
If you want to use this code to generate a java.awt.BufferedImage, simply instantiate a class that extends
Canvas and then access the 'imageBuffer' field on it.
<code>val image = ((new MyCanvas).imageBuffer)</code>
</p>

<h2> Actually getting this code working  </h2>

<p>
    You will need 3 things in order to actually start manipulating images programmatically.
</p>
        <ol>
            <li>
                The Scala Compiler
            </li>
            <li>
                An IDE that supports Scala
            </li>
            <li>
                My library
            </li>
        </ol>
<p><small>(SBT support coming soon)</small></p>(SBT support coming soon)

<p>
    Once you have the above required programs and library, it is time to actually run some code.
    Fortunately, I've made it incredibly easy to do so!
</p><p>
    The Canvas class contains all the functions that you've been reading about, so we simply need
    to do one extension and we're good.  The complete code for the previous example is just this:
</p>

{% include code %}
{% highlight scala %}
import com.prealpha.Canvas
object MyCanvas extends Canvas {
    load("example_input/trees.jpg")

    show("unscaled")

    scale(0.5)
    width /= 2
    height /= 2

    show("scaled")
}
{% endhighlight %}
{% include inbetween %}
<img src ="./example_output/trees.png" />
{% include image %}

<p>
    Notice that the only difference between my example scripts and the code that actually runs is the
    import and that we wrap everything in an `object` that extends `Canvas`!  Because `Canvas` extends `App`,
    the entrypoint to our program is also inside MyCanvas as well!  We can have a fully running image generator
    in fewer lines than it takes to write "Hello World" in Java.
</p>
